\documentclass[a4paper,12pt]{article}
%\usepackage[a4paper, nohead, left=30mm, right=20mm, top=20mm, bottom=20mm]{geometry}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[dvips]{color}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{float}
\usepackage[ruled]{algorithm}
\usepackage{algorithmic}

\graphicspath{{figures/}}

\def\figureref#1{рис.\,\protect\ref{#1}}
\let\picref=\figureref
\def\eqdef{\mathrel{{:}=}}
%\def\eqref#1{(\protect\ref{#1}\protect)}

\def\MOD{{\bf mod} \,}
%\def\OR{{\bf or} \,}
%\def\NOT{{\bf not} \,}
%\def\AND{{\bf and} \,}

\floatname{algorithm}{Алгоритм}
\theoremstyle{plain}
\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\theoremstyle{definition}
\newtheorem{definition}{Определение}

\newcount\siccount
\long\def\sic#1{\advance\siccount by1{\color[rgb]{0.1,0.5,0.1}#1}\marginpar{\bf\the\siccount}}

\begin{document}
\title{Быстрая генерация неизоморфных вложенных букетов окружностей}
\author{В.\,Р.\,Мешков, А.\,С.\,Мишунин, А.\,В.\,Омельченко}
\maketitle

\section{Хордовые диаграммы}

Статья посвящена перечислению вложенных букетов окружностей или одновершинных вложенных графов, однако мы начнем с определения
другого объекта~--- т.\,н.~хордовых диаграмм. Как мы увидим, имеется взаимнооднозначное соответствие между множеством вложенных
букетов и множеством хордовых диаграмм. Это дает нам возможность пользоваться удобным и несколько более универсальным языком
хордовых диаграмм. (К тому же, их немного проще воспринимать визуально.)
\begin{figure}[ht]
\centering
\includegraphics{bouq01.mps}
\caption{\footnotesize Примеры хордовых диаграмм; хорды пронумерованы\label{figure:chord-samples}}
\end{figure}
\begin{definition}
\textit{Хордовая диаграмма порядка $n$} --- это ориентированная окружность с $2n$ различными отмеченными точками (вершинами),
произвольным образом разбитыми на пары.
\end{definition}
Для наглядного изображения, вершины каждой пары соединяют линиями (хордами) (см.~\figureref{figure:chord-samples}); вершины
удобно считать расположенными в равноотстоящих точках окружности $(\cos\pi\frac{i}{n},\sin\pi\frac{i}{n})$,
$i\in\{0,1,\dots,2n{-}1\}$. Хордовые диаграммы рассматриваются как чисто комбинаторный объект: важно лишь в каком порядке
вершины расположены на окружности и как они спарены.

Существует обширная литература, посвященная перечислению и классификации хордовых диаграмм
\cite{CoryMarcus1998,Flajolet2000,Stoimenow2000,Sawada2002}, а также применению их как удобного вспомогательного инструмента в
задачах различного рода (пожалуй, наибольшее число приложений хордовые диаграммы находят в маломерной топологии, в первую
очередь, в теории узлов \cite{Zvonkin2010,Duzhin2010}). Однако, несмотря на то что про хордовые диаграммы известно уже очень
много, каждый раз, когда они возникают в той или иной новой задаче, появляется необходимость классифицировать их по новым
признакам, важным с точки зрения данной задачи.

Наш интерес к хордовым диаграммам также связан с задачей теории узлов. Немного ниже мы укажем основные интересующие нас
характеристики хордовых диаграмм. Подчеркнем, что нашей целью является алгоритм, который позволяет сгенерировать полный набор
диаграмм с теми или иными свойствами, а не просто подсчитать их число.

\section{Вложенные графы}

Один и тот же граф можно нарисовать на замкнутых поверхностях различного рода. Говорят, что граф $\Gamma$ \textit{вложен} в
поверхность~$S$, если ребра $\Gamma$ разрезают $S$ на \textit{клетки} (или \textit{грани}), гомеоморфные кругу\footnote{Наличие
неодносвязных клеток эквивалентно наличию у поверхности $S$ дополнительных <<ручек>>, которые можно убрать, не меняя структуры
вложения.}.
\begin{figure}[ht]
\centering
\includegraphics{bouq02.mps}
\caption{\footnotesize Вложения 3-валентного графа, образованного ребрами куба, в поверхности рода 0,1,2;
поверхность сферы делится на шесть 4-угольных граней, поверхность тора~--- на четыре 6-угольных,
а поверхность кренделя~--- на две 12-угольных
\label{figure:cube}}
\end{figure}
Ограничения на возможный род вложения заданного связного графа следуют из формулы Эйлера
$$
v-e+f=2-2g,
$$
где $v,e$ и $f$~--- число вершин, ребер графа и число клеток вложения соответственно, $g$~--- род поверхности (число ручек).
Учитывая, что $f\ge1$, получаем, например, что для графа, образованного ребрами куба, могут существовать вложения с~$g=0,1,2$
(\picref{figure:cube}). Не всякая возможность, допускаемая для данного графа формулой Эйлера, реализуется, а если реализуется,
то соответствующих вложений может быть несколько. Однако оказывается, можно ввести на графе очень простую дополнительную
структуру, которая однозначно определяет соответствующее вложение.
\begin{definition}
\textit{Вложенным графом} (также \textit{ленточным} или \textit{толстым}) называется связный мультиграф\footnote{т.\,е.~граф, в
котором пара вершин может быть соединена несколькими ребрами} с фиксированным циклическим порядком ребер в каждой вершине.
\end{definition}

Понять, каким образом циклический порядок определяет вложение, проще всего используя <<ленточную>> интерпретацию вложенных
графов. Чтобы получить ленточный граф, нужно изобразить на плоскости вершины графа с отрезками ребер, расположенными в заданном
циклическом порядке, а затем соединить лентами (без перекручивания) отрезки с одинаковыми номерами
(\picref{figure:fat-graphs}a). Край полученного двумерного многообразия состоит из нескольких компонент. (Чтобы выделить их,
достаточно двигаться по краю ленты, начиная с некоторой точки, до возвращения в ту же точку (\picref{figure:fat-graphs}b).)
Каждая компонента соответствует клетке вложения, их число позволяет определить род поверхности по формуле
Эйлера\footnote{Читатель без труда определит род вложения ленточного графа \picref{figure:fat-graphs}a.} (см.~также
\picref{figure:cube}).
\begin{figure}[ht]
\centering
\includegraphics{bouq03.mps}
\caption{\footnotesize <<Созвездие>> с пронумерованными отрезками ребер и ленточный граф;
одновершинный ленточный граф рода 2 (выделены границы трех граней из четырех)\label{figure:fat-graphs}}
\end{figure}
Заметим, что вложения графов рассматриваются с точностью до гомеоморфизмов поверхности вложения; в группу гомеоморфизмов
замкнутой двумерной поверхности помимо непрерывных деформаций входят также нетривиальные гомеоморфизмы~---
т.\,н.~\textit{скручивания Дена} (см., например, \cite{Zvonkin2010}).


\section{Что именно мы будем перечислять}

В статье \cite{We_Tangles2010} этого сборника вводится представление <<тангл-букет>> для виртуальных зацеплений (терминологию
см.~в \cite{We_Tangles2010}). Сейчас нас интересует вторая составляющая этого представления.
\begin{definition}
\textit{Вложенным букетом окружностей} называется одновершинный граф с фиксированным циклическим порядком ребер.
\end{definition}
Примеры вложенных букетов приведены на \picref{figure:bouquet-CD}, из этого же рисунка явствует прямая связь хордовых диаграмм
со вложенными букетами. Первый букет на \picref{figure:bouquet-CD} имеет род~2, т.\,е.~вкладывается в крендель
(\picref{figure:genus2}), второй, очевидно, является планарным.
\begin{figure}[ht]
\centering
\includegraphics{bouq06.mps}
\caption{\footnotesize Вложенные букеты и хордовые диаграммы\label{figure:bouquet-CD}}
\end{figure}
\begin{figure}[ht]
\centering
\includegraphics{bouq04.mps}
\caption{\footnotesize Вложение, соответствующее букету \picref{figure:bouquet-CD}a\label{figure:genus2}}
\end{figure}
Поскольку с точки зрения исходной задачи мы не различаем изоморфные букеты, то же самое следует делать и для хордовых диаграмм.
Все возможные изоморфизмы одновершинных графов сводятся к поворотам и отражениям в порядке ребер, то есть к поворотам и
отражениям соответствующей хордовой диаграммы. Поэтому мы будем использовать следующее определение эквивалентности.
\begin{definition}
Две ходовые диаграммы (с одинаковым числом хорд) считаются \textit{эквивалентными}, если одна из них может быть получена из
другой поворотом окружности или ее зеркальным отражением.
\end{definition}

Остановимся на некоторых специальных свойствах вложенных букетов, интересных с точки зрения классификации виртуальных
зацеплений.

Ребро вложенного графа назовем \textit{петлей}, если оно может быть стянуто в точку на поверхности вложения
(\picref{figure:bouquet-CD}b). Соответствующая хордовая диаграмма содержит хорду единичной длины (как первая диаграмма на
\picref{figure:chord-samples}). Для перечисления виртуальных зацеплений, такие диаграммы не представляют интереса, поскольку
петли букета всегда можно <<втянуть>> внутрь тангла, а значит, найдется и представление данного зацепление с букетом без
петель.

Будем говорить, что два ребра вложенного букета \textit{параллельны}, если они гомотопны на поверхности вложения или, иначе
говоря, если они ограничивают 2-угольную клетку. В хордовой диаграмме параллельным ребрам соответствуют \textit{параллельные
хорды}, т.\,е.~хорды, которые оканчиваются в соседних точках окружности и не пересекаются. Например, вторая диаграмма на
\picref{figure:chord-samples} содержит две пары параллельных хорд.
\begin{definition}
Букет, не содержащий петель и параллельных ребер, будем называть \textit{простым}.
\end{definition}
Простые букеты являются, в каком-то смысле, базисными, поскольку любой букет можно получить из простого букета, заменив
некоторые из его ребер на <<пучки>> параллельных. Поэтому перечисление простых букетов и соответствующих им диаграмм
представляет особый интерес. Отметим, что число простых букетов заданного рода конечно, так как максимальное число попарно
негомотопных замкнутых кривых с одной общей точкой на поверхности рода $g$ равно $6g-3$.

Следующий интересный класс букетов образуют т.\,н.~шахматные букеты.
\begin{definition}
Вложенный граф называется \textit{шахматным}, если клетки вложения можно раскрасить в два цвета так, что каждое ребро будет
разделять клетки разных цветов, т.\,е. клетки допускают правильную 2-раскраску.
\end{definition}
Очевидно, необходимым условием для <<шахматности>> является четная валентность всех вершин графа; вложенные букеты
удовлетворяют этому условию автоматически. Шахматные букеты представляют интерес в связи с задачей перечисления
\textit{альтернированных} виртуальных зацеплений (см.~\cite{We_Tangles2010}). Оказывается, 4-валентный вложенный граф (проекция
зацепления) допускает альтернированную расстановку перекрестков тогда и только тогда когда он является шахматным. А поскольку
граф любого тангла может быть раскрашен шахматным образом, шахматность виртуальной проекции, получаемой <<склеиванием>>
проекции тангла и вложенного букета, зависит только от шахматности последнего. Таким образом, для перечисления альтернированных
зацеплений нам необходимы только шахматные букеты. На языке хордовых диаграмм, шахматность означает, что все хорды имеют
нечетные длины (см., например, третью диаграмму на \picref{figure:chord-samples}).

Мы переходим к описанию алгоритма генерации хордовых диаграмм.


\section{Алгоритм}

Для перечисления хордовых диаграмм удобно использовать следующее машинное представление. Пронумеруем вершины естественным
образом~--- по порядку их расположения на окружности (\picref{figure:chord-code}); затем сопоставим диаграмме
последовательность $\alpha = a_0 a_1 a_3 \dots a_{2 n - 1}$ из $2 n$ чисел, в которой на $i$-той позиции стоит $(j - i)$ \MOD
$2 n$, где $j$~--- номер противоположного конца хорды, инцидентной $i$-той вершине. Легко показать, что две диаграммы дают
одинаковые коды тогда и только тогда, когда они эквивалентны. Также заметим, что при поворотах диаграмм единственное, что
происходит с их кодами~--- циклические сдвиги, а при их отражениях~--- замена $a_i$ на $2 n - a_i$ и отражения кодов. Назовем
\textit{длиной хорды} минимум из двух чисел, стоящих в коде на позициях, соответствующих концам этой хорды.
\begin{figure}[!t]
\centering
\includegraphics{bouq05.mps}
\caption{Диаграмма с кодом $\alpha = 6\,2\,3\,6\,3\,5\,2\,5$. \label{figure:chord-code}}
\end{figure}


\subsection{Хордовые диаграммы с точностью до поворотов}

Эффективный алгоритм для перечисления хордовых диаграмм с точность до поворотов был предложен в работе \cite{Sawada2002}. Мы
приведем его изложение в несколько упрощенной форме, а затем покажем, что нужно добавить, чтобы учесть отражения.

Пусть последовательность $\alpha = a_0 a_1 a_3 \dots a_{2 n - 1}$ является представлением какой-либо хордовой диаграммы с $n$ хордами
согласно схеме, изложенной выше. Определим $pos_i(\alpha)$ как возрастающую последовательность (возможно пустую), составленную из всех
номеров позиций $j$ таких, что $a_j = i$. Также определим $\pi_k(\alpha) = pos_1(\alpha) \cdot pos_2(\alpha) \cdot pos_3(\alpha) \dots
pos_{k - 1}(\alpha) \cdot pos_k(\alpha)$ и $f(\alpha) = \pi_{2 n - 1}(\alpha)$. Среди всех возможных представлений $\alpha$ конкретной
хордовой диаграммы назовем каноническим то, которое дает лексикографически минимальное значение $f(\alpha)$. Заметим, что для сравнения
важна только первая половина $f(\alpha)$, так как вторая однозначно по ней определяется.

Алгоритм, предложенный в \cite{Sawada2002}, по сути является перебором с возвратом, который по ходу выполнения поддерживает
представление $\alpha$ текущей хордовой диаграммы (возможно не достроенное) и последовательно добавляет в него сначала все
хорды длины 1, затем все хорды длины 2, 3 и так далее; одновременно с этим строятся соответствующие $pos_i(\alpha)$. В процессе
добавления алгоритм следит за тем, чтобы для $\alpha$ не существовало циклического сдвига, приводящего к меньшему значению
$\pi_i(\alpha)$ (ветви, нарушающие это условие отсекаются) и поддерживает текущий период представления, то есть минимальный
циклический сдвиг, приводящий к такому-же $\pi_i(\alpha)$.

\begin{algorithm}[!t]\label{algorithm:generate}\small
    \caption{\small$generate(chord\_len, period)$}
    \algsetup{linenosize=\small, linenodelimiter=.}
    \begin{algorithmic}[1]
        \IF{chords = n}
            \STATE $print()$
            \RETURN
        \ENDIF

        \IF{$period = 2 n$ \OR $chord\_len = n$}
            \STATE $matchRest(chord\_len)$
        \ELSE
            \STATE $placeChords(chord\_len, period, 0, 0, 0, 0)$
        \ENDIF
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!t]\label{algorithm:matchRest}\small
    \caption{\small$matchRest(min\_chord)$}
    \algsetup{linenosize=\small, linenodelimiter=.}
    \begin{algorithmic}[1]
        \IF{chords = n}
            \STATE $print()$
            \RETURN
        \ENDIF

        \STATE $s \leftarrow firstEmpty()$
        \STATE $e \leftarrow nextEmpty(s)$

        \WHILE{$e < 2 n$ \AND $2 n + s - e \ge min\_chord$}
            \IF{$e - s \ge min\_chord$}
                \STATE $addChord(s, e)$
                \STATE $matchRest(min\_chord)$
                \STATE $deleteChord(s, e)$
            \ENDIF
            \STATE $e \leftarrow nextEmpty(e)$
        \ENDWHILE
    \end{algorithmic}
\end{algorithm}

Основной функцией, собственно и осуществляющей перебор с возвратом, является $generate$. Ее двумя параметрами являются длина
хорд, которые мы собираемся сейчас расставлять, и период текущего состояния представления $\alpha$ соответственно. Работа
алгоритма начинается в вызова $generate(1, 1)$, поскольку, как уже было сказано, мы сначала расставляем хорды длины один, а для
пустого представления любой циклический сдвиг приводит к одному и тому же значению $\pi_i(\alpha)$ (пустому). Внутри $generate$
производит следующие действия:
\begin{enumerate}
\item
Если текущая хордовая диаграмма полностью заполнена, то выводит последнюю и возвращается.
\item
Если период совпал с длиной представления (то есть симметрии нет и, что бы мы не поставили дальше, свойство минимальности
текущего циклического сдвига не нарушится) или в качестве длины хорд пришло $n$ (такие хорды гарантированно не влияют на
симметрию), то мы вызываем процедуру $matchRest$ (Алгоритм \ref{algorithm:matchRest}) которая просто перебирает все способы
заполнить свободные позиции в представлении хордами не короче, чем значение ее параметра.
\item
В остальных случаях вызывается процедура $placeChords$ (Алгоритм \ref{algorithm:placeChord}), которая перебирает все
способы расставить хорды заданной длины, не нарушив при этом свойство минимальности циклического сдвига.
\end{enumerate}

\begin{algorithm}[!t]\label{algorithm:placeChord}
\caption{\small$placeChords(cl, p, chunk, pos, lyn, lower)$}
\algsetup{linenosize=\small, linenodelimiter=.}
\begin{algorithmic}[1]
    \IF{$chunk \cdot p = 2 n$}
        \IF{$pos$ \MOD $lyn = 0$}
            \STATE $generate(cl + 1, \frac{2 n \cdot lyn}{pos})$
        \ENDIF
        \RETURN
    \ENDIF

    \IF{$pos = 0$}
        \STATE $bottom \leftarrow lower$
    \ELSE
        \STATE $bottom \leftarrow max(lower, code[cl] [pos - lyn])$
    \ENDIF

    \FOR{$j \in \{ bottom \dots p \}$}
        \STATE $code[ cl ] [ pos ] \leftarrow j$

        \IF{$pos > 0$ \AND $j = code[ cl ] [ pos - lyn ]$}
            \STATE $next\_lyn \leftarrow lyn$
        \ELSE
            \STATE $next\_lyn \leftarrow pos + 1$
        \ENDIF

        \IF{$j < p$}
            \STATE $u \leftarrow chunk \cdot p + j$
            \STATE $v \leftarrow (u + cl)$ \MOD $2 n$

            \IF{$isEmpty(u)$ \AND $isEmpty(v)$}
                \STATE $addChord(u, v)$
                \STATE $placeChord(cl, p, chunk, pos + 1, next\_lyn, j + 1)$
                \STATE $deleteChord(u, v)$
            \ENDIF
        \ELSE
            \STATE $placeChords(cl, p, chunk + 1, pos + 1, next\_lyn, 0)$
        \ENDIF
    \ENDFOR
\end{algorithmic}
\end{algorithm}

Работа процедуры $placeChords$ основана на следующем факте: пусть мы только что закончили расставлять хорды длины $l$, а период представления,
определяемый $\pi_{l - 1}(\alpha)$ (минимальным среди всех возможных сдвигов) равен $p$. Разделим $pos_l(\alpha)$ на $\frac{2 n}{p}$ блоков по
результату целочисленного деления чисел на $p$ (некоторые блоки могут оказаться пустыми). Затем заменим в каждом из них числа на их остатки по
модулю $p$ и добавим каждому в конец $p$. Объединим полученные блоки в том же порядке, получив новую последовательность $pos_l'(\alpha)$.
Тогда свойство минимальности не нарушается только и только в том случае, если $pos_l'(\alpha)$ является ожерельем, то есть лексикографически
не больше любого своего циклического сдвига.

Алгоритм генерации ожерелий базируется на декомпозиции Линдона и алгоритме Дюваля \cite{Duval1983} и подробно описан в работах
\cite{RuskeySawada1999, Sawada2001}. Процедура $placeChords$ является его небольшой модификацией.

В процедуре $matchRest$ используются две вспомогательные процедуры $firstEmpty()$ и $nextEmpty(p)$, которые возвращают первую
свободную позицию в диаграмме и следующую свободную позицию за своим параметром. Поддерживая в процессе добавления и удаления
хорд список свободных позиций, эти процедуры можно реализовать за время $O(1)$.

\subsection{Отражения}

Для начала переопределим каноническое представление $\alpha$ как дающее лексикографически минимальное значение $f(\alpha)$
среди всех поворотов и отражений диаграммы. По ходу выполнения модифицированного алгоритма мы по-прежнему будем поддерживать
текущее (незавершенное) представление каноническим по известному к тому моменту префиксу $f(\alpha)$, однако теперь необходимо
учитывать и симметрии, связанные с отражением. Для этого добавим к параметрам процедур $generate$ и $placeChords$ еще
информацию о наличии или отсутствии зеркальной симметрии и номер позиции, с которой начинается отражение, дающее минимальное
значение $f$, при наличии такой симметрии.

Процедуру $matchRest$ мы модифицировать не будем, в код $generate$ добавим передачу новых параметров далее в $placeChord$ и
учтем наличие зеркальности при проверке группы симметрии на тривиальность, когда мы решаем вызвать ли нам $matchRest$.

\begin{algorithm}[!t]\label{algorithm:checkSymmetry}\small
\caption{\small$checkSymmetry(cl, p, m, base, len, new\_p)$} \algsetup{linenosize=\small, linenodelimiter=.}
\begin{algorithmic}[1]

    \IF{$\NOT m$}
        \STATE $generate(cl + 1, new\_p, \FALSE, 0)$
        \RETURN
    \ENDIF

    \STATE $base \leftarrow (base - cl)$ \MOD $p$
    \STATE $begin \leftarrow (\min \{ \, i \, | \, code[cl] [i] > base\} - 1)$ \MOD $len$

    \STATE $index \leftarrow 0$
    \STATE $flip \leftarrow \FALSE$

    \FOR{$i \in \{ 0 \dots len - 1 \}$}
        \STATE $value \leftarrow code[cl] [ (begin + len - i)$ \MOD $len ]$

        \IF{$flip$ \AND $(value \le base$ \OR $value = p)$}
            \STATE $tmp[index] \leftarrow p$
            \STATE $index \leftarrow index + 1$
            \STATE $flip \leftarrow \FALSE$
        \ENDIF

        \IF{$value < p$}
            \STATE $tmp[index] \leftarrow (base - value)$ \MOD $p$
            \STATE $index \leftarrow index + 1$
        \ELSE
            \STATE $flip \leftarrow \TRUE$
        \ENDIF
    \ENDFOR

    \IF{$flip$}
        \STATE $tmp[index] \leftarrow p$
    \ENDIF

    \STATE $min\_shift \leftarrow minCyclicShift(tmp)$

    \IF{$code[cl] < tmp[min\_shift] \dots$}
        \STATE $generate(cl + 1, new\_p, \FALSE, 0)$
        \RETURN
    \ENDIF

    \IF{$code[cl] = tmp[min\_shift] \dots$}
        \STATE $flips \leftarrow |\{ \, j \, | \, j < min\_shift$ \AND $tmp[j] = p \}|$
        \STATE $new\_base \leftarrow (base - p \cdot flips)$ \MOD $2 n$
        \STATE $generate(cl + 1, new\_p, \TRUE, new\_base)$
    \ENDIF
\end{algorithmic}
\end{algorithm}

В процедуре $placeChords$, кроме передачи параметров зеркальности дальше, заменим вызов $generate(cl + 1, \frac{2 n \cdot lyn}{pos})$
на вызов новой процедуры $checkSymmetry(cl, p, mirror, mirror\_base, pos, \frac{2 n \cdot lyn}{pos})$, которая и должна заниматься
обработкой разных случаев зеркальной симметрии.

Если зеркальная симметрия уже была разрушена ранее, то $checkSymmetry$, очевидно, должна просто вызвать $generate$. В противном
случае работа процедуры базируется на том факте, что позиция, с которой начинается отражение, дающее минимальное значение
$\pi_l$ отличается от позиции, дающей минимальное значение $\pi_{l - 1}$, на число, кратное периоду, определяемому $\pi_{l -
1}$, --- простое следствие, того, что отраженное представление имеет тот же период, что и неотраженное. Следовательно можно
воспользоваться тем же приемом с последовательностью из остатков, что был использован при построении процедуры $placeChords$.
Задача сводится к построению соответствующей отраженной последовательности и поиску в ней минимального циклического сдвига.
Последнее можно за линейное время выполнить алгоритмом Дюваля \cite{Duval1983}. Остается сравнить прямую последовательность из
остатков (сгенерированную процедурой $placeChords$) с полученным минимальным циклическим сдвигом, отсечь случаи, где зеркальная
последовательность лексикографически меньше и, при необходимости, пересчитать параметры зеркальной симметрии.

Хотя принцип работы $checkSymmetry$ выглядит достаточно просто, реализация ее изобилует <<подводными камнями>>. В частности,
следует не забывать о том, что остаток от деления отрицательных чисел процессором вычисляется неверно.

\section{Результаты}

Для проверки построенного алгоритма были перечислены все хордовые диаграммы с числом хорд до 13 включительно с точностью до
поворотов и отражений, но без учета нетривиальных симметрий. Полученные числа совпадают с теми, что дает соответствующая
производящая функция, приведенная в \cite{Liskovets2000}. Однако, вспомним, что нас интересуют вложенные букеты, не содержащие
<<планарной>> части, то есть, в переводе на язык хордовых диаграмм, диаграммы не содержащие хорд единичной длины. Чтобы
получать только такие диаграммы, необходимо произвести последнюю модификацию алгоритма, а именно передавать в первом запуске
процедуры $generate$ два в качестве длины хорды.

Таблица \ref{table:total-count} дает общее число вложенных букетов из $n$ окружностей, не содержащих петель. Там же приведены
данные, характеризующие время работы алгоритма~--- среднее число итераций $N$ на одну диаграмму. К сожалению, строгое
доказательство оценки на время работы алгоритма представляется весьма трудоемким и остается пока открытой проблемой. В пользу
того, что время работы пропорционально общему числу генерируемых диаграмм, свидетельствуют лишь экспериментальные данные,
приведенные в \cite{Sawada2002} и таблице~\ref{table:total-count}. В нашем случае <<число итераций>> рассчитывалось как суммарное
количество рекурсивных вызовов плюс суммарное число итераций всех внутренних циклов.

\begin{table}[!t]\footnotesize
\caption{\small Количество диаграмм\label{table:total-count}} \centering
\begin{tabular}{|r||r|r|}
\hline
$n$ & \# & N \\
\hline\hline
 2 &                 1 &   8.0 \\
 3 &                 2 &  84.5 \\
 4 &                 7 & 160.7 \\
 5 &                29 & 211.1 \\
 6 &               196 & 179.2 \\
 7 &            1\,788 & 123.1 \\
 8 &           21\,994 &  71.6 \\
 9 &          326\,115 &  42.2 \\
10 &       5\,578\,431 &  29.0 \\
11 &     107\,026\,037 &  23.0 \\
12 &  2\,269\,254\,616 &  20.0 \\
13 & 52\,638\,064\,494 & 18.29 \\
\hline
\end{tabular}
\end{table}

Основной результат работы содержится в таблице \ref{table:by-genus}, где букеты классифицированы по роду $g$ вложения.
Применительно к задаче перечисления виртуальных зацеплений, такая классификация позволит рассматривать зацепления каждого рода
отдельно от остальных.
\begin{table}[!t]\footnotesize
\caption{\small Распределение вложенных букетов по роду\label{table:by-genus}} \centering
\begin{tabular}{|c||r|r|r|r|r|r|}
\hline
$n \setminus g$
   &  1 &       2 &            3 &                4 &                 5 &                 6 \\
\hline\hline
2  &  1 &       . &            . &                . &                 . &                 . \\
3  &  2 &       . &            . &                . &                 . &                 . \\
4  &  3 &       4 &            . &                . &                 . &                 . \\
5  &  4 &      25 &            . &                . &                 . &                 . \\
6  &  6 &     108 &           82 &                . &                 . &                 . \\
7  &  7 &     370 &       1\,411 &                . &                 . &                 . \\
8  &  9 &  1\,089 &      13\,638 &           7\,258 &                 . &                 . \\
9  & 11 &  2\,822 &      91\,661 &         231\,621 &                 . &                 . \\
10 & 13 &  6\,623 &     478\,123 &      3\,602\,043 &       1\,491\,629 &                 . \\
11 & 15 & 14\,328 &  2\,062\,183 &     36\,849\,649 &      68\,099\,862 &                 . \\
12 & 18 & 28\,992 &  7\,666\,595 &    282\,274\,848 &  1\,472\,428\,884 &     506\,855\,279 \\
13 & 20 & 55\,407 & 25\,284\,542 & 1\,741\,085\,399 & 20\,569\,202\,305 & 30\,302\,436\,821 \\
\hline
\end{tabular}
\end{table}

Следующая таблица (табл.~\ref{table:prime}) содержит данные о распределении по роду для \textit{простых} вложенных букетов.
Ниже, в приложении, приведены изображения хордовых диаграмм, соответствующих простым букетам рода 1 и 2.
\begin{table}[!t]\footnotesize
\caption{\small Распределение простых вложенных букетов по роду\label{table:prime}} \centering
\begin{tabular}{|c||r|r|r|r|r|r||r|}
\hline
$n \setminus g$ &  1 &  2 &  3 &  4 &  5  & 6  & total\\\hline\hline
2  &  1  &   .   &  .      &   .          &   .           &  .            &                    1                   \\
3  &  1  &   .   &  .      &   .          &   .           &  .            &                    1                   \\
4  &  .  &   4   &  .      &   .          &   .           &  .            &                    4                   \\
5  &  .  &   18  &  .      &   .          &   .           &  .            &                    18                  \\
6  &  .  &   34  &  82     &   .          &   .           &  .            &                    116                 \\
7  &  .  &   38  &  1\,022   &   .          &   .           &  .            &                  1\,060              \\
8  &  .  &   20  &  5\,741   &   7\,258       &   .           &  .            &                13\,019             \\
9  &  .  &   8   &  18\,281  &   175\,136     &   .           &  .            &                193\,425            \\
10 &  .  &   .   &  36\,232  &   1\,785\,661    &   1\,491\,629     &  .            &          3\,313\,522         \\
11 &  .  &   .   &  46\,784  &   10\,404\,521   &   53\,216\,483    &  .            &          63\,667\,788        \\
12 &  .  &   .   &  39\,296  &   39\,253\,436   &   805\,552\,733   &  506\,855\,279    &      1\,351\,700\,744    \\
13 &  .  &   .   &  20\,978  &   102\,396\,728  &   7\,067\,326\,462  &  24\,220\,951\,540  &  31\,390\,695\,708   \\
\hline
\end{tabular}
\end{table}

Наконец, таблица \ref{table:cheq} содержит информацию о шахматных вложенных букетов, которые нужны для перечисления
альтернированных зацеплений. Как видно из этой таблицы, относительная доля шахматных букетов очень быстро уменьшается с
увеличением рода вложения. Это говорит о том, что в отличие от случая обычных (рода 0) зацеплений, когда множество
альтернированных зацеплений совпадает со множеством всех возможных проекций, для зацеплений рода 1 и выше информации только об
альтернированных зацеплениях недостаточно для перечисления всех зацеплений данного рода.
\begin{table}[!t]\footnotesize
\caption{\small Распределение шахматных вложенных букетов по роду\label{table:cheq}} \centering
\begin{tabular}{|c||r|r|r|r|r|r||r|}
\hline
$n \setminus g$ &  1 &  2 &  3 &  4 &  5  & 6  & total\\\hline\hline
2  & . &    . &      . &       . &       . &       . &        . \\
3  & 1 &    . &      . &       . &       . &       . &        1 \\
4  & 1 &    . &      . &       . &       . &       . &        1 \\
5  & 1 &    3 &      . &       . &       . &       . &        4 \\
6  & 2 &    7 &      . &       . &       . &       . &        9 \\
7  & 2 &   25 &     16 &       . &       . &       . &       43 \\
8  & 3 &   69 &    126 &       . &       . &       . &      198 \\
9  & 3 &  177 &    972 &     283 &       . &       . &     1\,435 \\
10 & 4 &  411 &   5\,333 &    5\,864 &       . &       . &    11\,612 \\
11 & 4 &  871 &  24\,428 &   74\,529 &   14\,267 &       . &   114\,099 \\
12 & 6 & 1\,783 &  94\,873 &  652\,067 &  494\,271 &       . &  1\,243\,000 \\
13 & 5 & 3\,355 & 323\,914 & 4\,426\,324 & 8\,886\,034 & 1\,321\,582 & 14\,961\,214 \\
\hline
\end{tabular}
\end{table}

Результаты, полученные здесь, наряду с результатами, описанными в \cite{We_Tangles2010}, планируется использовать для решения
задачи перечисления виртуальных зацеплений над поверхностями небольшого рода и, в первую очередь, зацеплений рода 1.


\section*{Приложение: простые букеты рода $g=1,2$}

\begin{figure}[ht]
\centering
\includegraphics{bouq98.mps}
\caption{\footnotesize Простых букетов рода 1 всего два\label{figure:simple1-table}}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics{bouq99.mps}
\caption{\footnotesize Все 122 простых букета рода 2\label{figure:simple2-table}}
\end{figure}

\begin{thebibliography}{88}
\bibitem{Duzhin2010}
{\em Chmutov~S., Duzhin~S., Mostovoy~J.\,} CDBook: Introduction to Vassiliev knot invariants. (Draft version of a book about
chord diagrams). 2010, 514\,p.

\bibitem{Zvonkin2010}
{\em Звонкин~А.\,К., Ландо~С.\,К.\,} Графы на поверхностях и их приложения. М.: МЦНМО, 2010, 480\,с.

\bibitem{CoryMarcus1998}
{\em Cori~R., Marcus~M.\,} Counting non-isomorphic chord diagrams. Theoret.~Comput.~Sci. 1998, {\bf204}, 55--73.

\bibitem{Stoimenow2000}
{\em Stoimenow~A.\,} On the number of chord diagrams. Discrete Math. 2000, {\bf218}, 109--233.

\bibitem{Flajolet2000}
{\em Flajolet~P., Noy~M.\,} Analytic combinatorics of chord diagrams. Formal Power Series and Algebraic Combinatorics, 2000,
191--201.

\bibitem{Gross1989}
{\em Gross~J., Robbins~D.\,P., and Tucker~T.\,W.\,} Genus distributions for bouquets of circles. J.~Combin.~Theory, Ser.\,B,
1989, {\bf47}, 292--306.

\bibitem{KwakShim2002}
{\em Kwak~J.\,H., Shim~S.\,H.\,} Total embedding distributions for bouquets of circles. Discrete Math. 2002, {\bf248}, 93--108.

\bibitem{We_Tangles2010}
{\em Мешков~В.\,Р., Мишунин~А.\,С., Омельченко~А.\,В.\,}
Перечисление альтернированных $k$-танглов. Настоящий сборник.

\bibitem{Sawada2002}
{\em Sawada~J.\,} A Fast Algorithm for Generating Nonisomorphic Chord Diagrams. SIAM Journal on Discrete Mathematics, 2002,
{\bf15}, 546--561.

\bibitem{RuskeySawada1999}
{\em Ruskey~F., Sawada~J.\,} An efficient algorithm for generating necklaces of fixed density. SIAM Journal on Computing, 1999,
{\bf 29}, 671--684

\bibitem{Sawada2001}
{\em Sawada~J.\,} Generating Bracelets in Constant Amortized Time. SIAM Journal on Computing, 2001, {\bf31}, 259--268.

\bibitem{Duval1983}
{\em Duval~J.-P.\,} Factoring words over an ordered alphabet. J.~Algorithms, 1983, {\bf4}, 363--381.

\bibitem{Liskovets2000}
{\em Liskovets~V.\,A.\,} Some easily derivable sequences. J.~Integer Sequences, 2000, {\bf3}, article 00.2.2.

\end{thebibliography}
\end{document}
